
f9b5a9bff65916bbfa554656f9c0d5a9dd09586c
more stuff in ljt_dnterm.v showing type error problem
line 788 of ljt_dnterm.v

at line 853, end, subst works, but 
d1 : dersrec LJArules emptyT (map (apfst (fmlsext Γ0 Γ3)) ps1)
apd : allDT (no_rpt_same seq_ord (prems:=emptyT))
          (derI (fmlsext Γ1 Γ2 [Imp (Var p) B], Var p) l d1)
H1 : Γ0 = Γ1
trying
> rewrite H1 in d1.
> ^^^^^^^^^^^^^^^^
Error: d1 is used in hypothesis apd.

whereas avoiding line 853, instead doing subst gives
d1 : dersrec LJArules emptyT (map (apfst (fmlsext (Γ1 ++ []) Γ3)) ps1)
> rewrite app_nil_r in d1.
> ^^^^^^^^^^^^^^^^^^^^^^^
Error: d1 is used in hypothesis d2.

more about error

error solved in da41748d316875ef426a2c50e9caa025e82ac260

try as for lja_dd_ImpL_p in f9b5a9bff65916bbfa554656f9c0d5a9dd09586c
this shows the error

(* now we can reproduce it, but must set implicit argument ps of the goal *)
(* note that this runs and shows error using latest commit of ljt (at 21/3/21)

Abort.
Lemma et (W : Set) (B G : W) (Γ3 : list W) (Vp Vp0 IVpB0 B0 : W)
  (rules : rlsT (srseq W)) (seq_ord : relationT (srseq W))
  (d1 : dersrec rules emptyT
         (map (apfst (app Γ3)) [([IVpB0], Vp0); ([B0], Vp)])) :
(@no_rpt_same_nu _ seq_ord rules (@emptyT _)
  (app Γ3 [IVpB0], Vp) [(app Γ3 [IVpB0], Vp0); (app Γ3 [B0], Vp)] d1).

Proof.  remember (map (apfst (app Γ3)) [([IVpB0], Vp0); ([B0], Vp)]) as lpst.

(* remember as lpst above changes type of d1 without changing type
  of implicit arg of no_rpt_same_nu in the goal
  before this, Check as below is OK, although type of d1 involves
  (map (apfst (app Γ3)) [([IVpB0], Vp0); ([B0], Vp)])
  and type of hidden arg of no_rpt_same_nu is
  [(app Γ3 [IVpB0], Vp0); (app Γ3 [B0], Vp)] *)

(*
Check (d1 : dersrec rules emptyT lpst).
Set Printing All.  Show.
(* Check (copy and paste goal, ie @no_rpt_same_nu ... d1). FAILS *)
Unset Printing All.
*)

assert (forall qs, no_rpt_same_nu seq_ord qs d1). admit.
Fail apply X.
Fail subst.

(* now try a self-contained example, simplifying no_rpt_same_nu,
  just load rtcT in general *)
Inductive derrec X (rules : list X -> X -> Type) (prems : X -> Type) :
  X -> Type :=
  | dpI : forall concl,
    prems concl -> derrec rules prems concl
  | derI : forall ps concl,
    rules ps concl -> dersrec rules prems ps -> derrec rules prems concl
with dersrec X (rules : list X -> X -> Type) (prems : X -> Type) :
  list X -> Type :=
  | dlNil : dersrec rules prems []
  | dlCons : forall seq seqs,
    derrec rules prems seq -> dersrec rules prems seqs ->
    dersrec rules prems (seq :: seqs)
    .

Definition no_rpt_same_nu U R rules prems (c0 : U) ps
  (dnu : dersrec rules prems ps) :=
  forall c1 c2 (d1 : derrec rules prems c1) (d2 : derrec rules prems c2),
    clos_transT R c2 c0.

Definition srseq A := prod (list A) A.
Definition apfst U V W (f : U -> V) (p : U * W) := let (x, y) := p in (f x, y).

Abort.
Lemma ets (W : Set) (B G : W) (Γ3 : list W) (Vp Vp0 IVpB0 B0 : W)
  (rules : rlsT (srseq W)) (seq_ord : relationT (srseq W))
  (d1 : dersrec rules emptyT
         (map (apfst (app Γ3)) [([IVpB0], Vp0); ([B0], Vp)])) :
(@no_rpt_same_nu _ seq_ord rules (@emptyT _)
  (app Γ3 [IVpB0], Vp) [(app Γ3 [IVpB0], Vp0); (app Γ3 [B0], Vp)] d1).

Proof.  remember (map (apfst (app Γ3)) [([IVpB0], Vp0); ([B0], Vp)]) as lpst.

assert (forall qs, no_rpt_same_nu seq_ord qs d1). admit.
Fail apply X. (* not failed *)
Fail subst. (* failed *)

(* so what has happened here? *)
(*
Check (d1 : dersrec rules emptyT lpst).
Set Printing All.  Show.
(* Check (copy and paste goal, ie @no_rpt_same_nu ... d1). STILL FAILS *)
Unset Printing All.
*)
