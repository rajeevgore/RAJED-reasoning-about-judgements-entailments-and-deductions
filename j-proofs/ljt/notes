
proof writeup notes, started Nov 2021, based on code at that time,
(for ljt, commit 7af8c80959b2955f36654965be17c61bed0a8acf 14 May 2021)
which would run on Coq 8.11.2 

history:

original paper uses "sensible proofs"
Contraction-Free Sequent Calculi for Intuitionistic Logic,
Roy Dyckhoff, JSL 57 (1992), 795-807 

simpler version, on which my proofs are based
Contraction-Free Sequent Calculi for Intuitionistic Logic,
Roy Dyckhoff & Sara Negri, JSL 65 (2000), 1499-1518

this is a correction/simplification to the 1992 paper, not used here
Contraction-Free Sequent Calculi for Intuitionistic Logic: A Correction,
Roy Dyckhoff, JSL 83 (2018), 1680-1682

thus references to lemma numbers in what follows and the code are
to the Dyckhoff & Negri 2000 paper (D&N)

General approach:

The standard system (with rule ImpLrule shown below) is called LJ.
Dyckhoff's system is called LJT.

We defined an alternative system which we called LJA, which consists
of Dyckhoff's LJT system, omitting his left Imp-atom rule ImpL_atom_rule
and replacing it by ImpLrule_p, which is the standard ImpL rule ImpLrule,
restricted to A being an atom.
Also for LJA (as for LJ) we omit the left-exchange rule.

ImpL_atom_rule [[B; Var p]] [Imp (Var p) B; Var p]
ImpLrule [([Imp A B], A); ([B], G)] ([Imp A B], G)
ImpLrule_p [([Imp (Var p) B], Var p); ([B], G)] ([Imp (Var p) B], G)

The reason for doing the is that his ImpL_atom_rule as shown above 
(without context) has two principal formulae, which makes many of our
generally useful lemmas inapplicable. 
For example, for LJA we do not need to include left-exchange as an explicit
rule, but for LJT we do.
We discuss the other consequences of this choice later.
But then we did it all for LJT as well, so three calculi studied.

In each system we restrict the axiom rule (Idrule) to atoms.

Description of file contents

NEED TO LOOK AT 
files ljt ljt_inv ljt_ctr ljt_dn ljt_dncc ljt_dnca

ALSO THESE
ljt_ca ljt_fp ljt_dnterm

file ljt.v: definitions, basic lemmas

PropF: formulae - constructors Var (atoms), Bot, Imp, And, Or
dnsubfml: a definition of subformula corresponding to the weight defined by D&N

dnfw, dnlw, dnsw - weights of formula, list of formulae, sequent,
noting that dnfw differs from D&N, having Bot -> 1, Var v -> 0

srseq, srseqf: the type of singleton-on-the-right sequent

LJsrrules, LJslrules: classes of rules (without context) according
to where context is added to make a rule of the system

LJTilrules, LJAilrules: some of Dyckhoff's special rules 

LJncrules, LJTSncrules, LJTncrules, LJAncrules: various sets of rules
(without left context)

LJrules, LJTSrules, LJTrules, LJArules: adding left context to the above

lemmas:
idrule_der_lj: the axiom rule (Idrule) for any formula is derivable 

Lemmas helping to prove Dyckhoff's rules are derivable 
lemmas LJ_ImpL_Or1, LJ_ImpL_Or2, LJ_ImpL_And, LJ_II

exchange admissible for LJ and LJA: exchL_lj, exchL_lja
these are easy using the lemma gen_seq.exchL_std_rule, 
which relies on the fact that each rule has at most one principal formula
on each side (so allows Idrule),
similar theorem for LJT (immediate due to exchange rule) exchL_ljt

weakening admissible for each system: LJweakening, LJAweakening, LJTweakening
and in a different form, insL_lj, insL_lja, insL_ljt

file ljt_inv.v invertibility of various rules 

first define the relation between conclusion and the premise of interest, eg

Inductive AndRinv1 {V} : relationT (PropF V) :=
  | AndRinv1_I : forall C D, AndRinv1 (And C D) C.

Inductive AndLinvs {V} : PropF V -> list (PropF V) -> Type :=
  | AndLinvs_I : forall C D, AndLinvs (And C D) ([C ; D]).

These are of varying types, we give them appropriate contexts to 
get relations applying to actual sequents.

For example, using functions such as

Inductive fslr (U W : Type) (R : U -> W -> Type) : list U -> W -> Type :=
    fslr_I : forall (u : U) (w : W), R u w -> fslr R [u] w

Inductive ant_rel (W Y : Type) (R : Y -> Y -> Type) : relationT (list W * Y) :=
    ant_relI : forall (ant : list W) (suc suc' : Y),
               R suc suc' -> ant_rel R (ant, suc) (ant, suc')

Others of the same nature are srs_ext_rel, rr_ext_rel.

Lemmas such as LJAIAE, LJAE, give the uniqueness of rules with a certain
form of conclusion, eg

Lemma LJAE V ps A B G : LJncrules ps ([@And V A B], G) -> ps = [([A ; B], G)].

We have a lot of lemmas which aren't very illuminating but capture
frequently used combinations or proof steps, eg lr_gen..., fcr..., 
ncgen..., and lemmas which are trivial but useful for automating proofs,
eg ser... and rre..., and tactics which use these, eg apser.... 

Then we have general invertibility results: the following lemmas
give conditions when the predicate can_trf_rules_rc 
(used in .. for proving an invertibility result) holds,
where the rule to be inverted has a single principal formula on the left
of the conclusion, which is replaced by a list of formulae in the premise in
question, and where the rule allows general contexts on left and right.

can_trf_genLinv_exch: if there is an exchange rule in the system,
then can_trf_rules_rc holds for the exchange rule itself

can_trf_genLinv_leml: can_trf_rules_rc holds for the rule whose
invertibility (for one of its premises) we want to prove,
for the case where a rule may have a list of principal formulae 

can_trf_genLinv_lem: can_trf_rules_rc holds for the rule which cannot
be inverted in the way in question

can_trf_genLinv_geni: can_trf_rules_rc holds when the only rule
(without context) applying to to an conclusion is the rule whose
invertibility we want to prove

there are further variations on the theme of these

Then we apply these results to prove invertibility of specific rules
for specific calculi LJ, LJA, LJT

Then some invertibility results need proving specifically, eg
can_trf_ImpRinv_lja and can_trf_ImpRinv_ljt
(invertibility of ImpR in LJA and LJT) 

Then, similarly, a general lemma for invertibility of right rules
(for which premises also have formula(e) on the right): can_trf_genRinv_lja.

Then we adapt previous proofs to LJT, first getting results for LJTSrules,
(which are the rules of LJT which have a single principal formula),
then extending them to LJTrules (noting that we can combine results
showing that can_trf_rules_rc holds, using the monotonicity
of can_trf_rules_rc, lemma can_trf_rules_rc_mono).

Much of the second half of the file is repeating similar proofs for the
systems LJA and LJT. 
Possibly more could be done by way of trying to find lemmas identifying 
common parts of two very similar proofs.

ljt_ctr.v - admissibility of contraction 

definitions: sctr_rel fml and lsctr_rel fmls define relations between two lists
of formulae, the second got by removing the second of two copies of
formula fml (for sctr_rel) or list of formulae fmls (for lsctr_rel)

for the above, fml or fmls appear at the start and end of the first list
so we need to use something like srs_ext_rel to supply the context

lemmas: 
gen_sctrL_And: if A and B are contractible, and the AndL rule is invertible,
and the AndL rule is in the calculus, then (And A B) is contractible 
gen_sctrL_Or is similar

then these are applied for the calculi LJ, LJA, LJT,
and results stated in terms of gen_step (see file gs-notes)

gs_ljg_rrules: the result in terms of gen_step where the last rule
is a right rule for And or Or (this should be pretty obvious since
we are doing contraction on the left, why is it so long to prove?)

lj[a/t]_ctr_lrls: where the last rule is a simple left rule and the subformulae
of the principal formula can be contracted, then the principal formula can
be contracted

gs_ljg_glrules: under appropriate conditions on the final rule,
the gen_step condition for contraction holds

gs_ljg_ImpR: the gen_step result for contraction where the last rule is ImpR
(for any of the calculi)

gs_lj[a]_ImpL: the gen_step result for contraction where the last rule is ImpL
for the calculus LJ[A]

ctr_adm_lj: admissibility of contraction for LJ

gs_ljg_exch: gen_step result for contraction where the last rule is exchange

gs_ljt_ImpL_atom: the gen_step result for contraction, for LJT,
where the last rule is the ImpL_atom_rule

lctr_adm_gen: extending contraction of one formula to 
contraction of a list of formulae

note, admissibility of contraction for LJT and LJA, 
  ctr_adm_ljt and ctr_adm_lja, are in ljt_dncc.v

ljt_dn.v: this file does not use contraction admissibility



