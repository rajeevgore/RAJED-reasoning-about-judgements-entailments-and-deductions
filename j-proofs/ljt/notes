
proof writeup notes, started Nov 2021, based on code at that time,
(for ljt, commit 7af8c80959b2955f36654965be17c61bed0a8acf 14 May 2021)
which would run on Coq 8.11.2 

history:

original paper uses "sensible proofs"
Contraction-Free Sequent Calculi for Intuitionistic Logic,
Roy Dyckhoff, JSL 57 (1992), 795-807 

simpler version, on which my proofs are based
Contraction-Free Sequent Calculi for Intuitionistic Logic,
Roy Dyckhoff & Sara Negri, JSL 65 (2000), 1499-1518

this is a correction/simplification to the 1992 paper, not used here
Contraction-Free Sequent Calculi for Intuitionistic Logic: A Correction,
Roy Dyckhoff, JSL 83 (2018), 1680-1682

thus references to lemma numbers in what follows and the code are
to the Dyckhoff & Negri 2000 paper (D&N)

General approach:

The standard system (with rule ImpLrule shown below) is called LJ.
Dyckhoff's system is called LJT.

We defined an alternative system which we called LJA, which consists
of Dyckhoff's LJT system, omitting his left Imp-atom rule ImpL_atom_rule
and replacing it by ImpLrule_p, which is the standard ImpL rule ImpLrule,
restricted to A being an atom.
Also for LJA (as for LJ) we omit the left-exchange rule.

ImpL_atom_rule [[B; Var p]] [Imp (Var p) B; Var p]
ImpLrule [([Imp A B], A); ([B], G)] ([Imp A B], G)
ImpLrule_p [([Imp (Var p) B], Var p); ([B], G)] ([Imp (Var p) B], G)

The reason for doing the is that his ImpL_atom_rule as shown above 
(without context) has two principal formulae, which makes many of our
generally useful lemmas inapplicable. 
For example, for LJA we do not need to include left-exchange as an explicit
rule, but for LJT we do.
We discuss the other consequences of this choice later.
But then we did it all for LJT as well, so three calculi studied.

In each system we restrict the axiom rule (Idrule) to atoms.

Description of file contents

NEED TO LOOK AT 
files ljt ljt_inv ljt_ctr ljt_dn ljt_dncc ljt_dnca

ALSO THESE
ljt_ca ljt_fp ljt_dnterm

file ljt.v: definitions, basic lemmas

PropF: formulae - constructors Var (atoms), Bot, Imp, And, Or
dnsubfml: a definition of subformula corresponding to the weight defined by D&N

dnfw, dnlw, dnsw - weights of formula, list of formulae, sequent,
noting that dnfw differs from D&N, having Bot -> 1, Var v -> 0

srseq, srseqf: the type of singleton-on-the-right sequent

LJsrrules, LJslrules: classes of rules (without context) according
to where context is added to make a rule of the system

LJTilrules, LJAilrules: some of Dyckhoff's special rules 

LJncrules, LJTSncrules, LJTncrules, LJAncrules: various sets of rules
(without left context)

LJrules, LJTSrules, LJTrules, LJArules: adding left context to the above

lemmas:
idrule_der_lj: the axiom rule (Idrule) for any formula is derivable 

Lemmas helping to prove Dyckhoff's rules are derivable 
lemmas LJ_ImpL_Or1, LJ_ImpL_Or2, LJ_ImpL_And, LJ_II

exchange admissible for LJ and LJA: exchL_lj, exchL_lja
these are easy using the lemma gen_seq.exchL_std_rule, 
which relies on the fact that each rule has at most one principal formula
on each side (so allows Idrule),
similar theorem for LJT (immediate due to exchange rule) exchL_ljt

weakening admissible for each system: LJweakening, LJAweakening, LJTweakening
and in a different form, insL_lj, insL_lja, insL_ljt

file ljt_inv.v invertibility of various rules 

first define the relation between conclusion and the premise of interest, eg

Inductive AndRinv1 {V} : relationT (PropF V) :=
  | AndRinv1_I : forall C D, AndRinv1 (And C D) C.

Inductive AndLinvs {V} : PropF V -> list (PropF V) -> Type :=
  | AndLinvs_I : forall C D, AndLinvs (And C D) ([C ; D]).

These are of varying types, we give them appropriate contexts to 
get relations applying to actual sequents.

For example, using functions such as

Inductive fslr (U W : Type) (R : U -> W -> Type) : list U -> W -> Type :=
    fslr_I : forall (u : U) (w : W), R u w -> fslr R [u] w

Inductive ant_rel (W Y : Type) (R : Y -> Y -> Type) : relationT (list W * Y) :=
    ant_relI : forall (ant : list W) (suc suc' : Y),
               R suc suc' -> ant_rel R (ant, suc) (ant, suc')

Others of the same nature are srs_ext_rel, rr_ext_rel.

Lemmas such as LJAIAE, LJAE, give the uniqueness of rules with a certain
form of conclusion, eg

Lemma LJAE V ps A B G : LJncrules ps ([@And V A B], G) -> ps = [([A ; B], G)].

We have a lot of lemmas which aren't very illuminating but capture
frequently used combinations or proof steps, eg lr_gen..., fcr..., 
ncgen..., and lemmas which are trivial but useful for automating proofs,
eg ser... and rre..., and tactics which use these, eg apser.... 

Then we have general invertibility results: the following lemmas
give conditions when the predicate can_trf_rules_rc 
(used in .. for proving an invertibility result) holds,
where the rule to be inverted has a single principal formula on the left
of the conclusion, which is replaced by a list of formulae in the premise in
question, and where the rule allows general contexts on left and right.

can_trf_genLinv_exch: if there is an exchange rule in the system,
then can_trf_rules_rc holds for the exchange rule itself

can_trf_genLinv_leml: can_trf_rules_rc holds for the rule whose
invertibility (for one of its premises) we want to prove,
for the case where a rule may have a list of principal formulae 

can_trf_genLinv_lem: can_trf_rules_rc holds for the rule which cannot
be inverted in the way in question

can_trf_genLinv_geni: can_trf_rules_rc holds when the only rule
(without context) applying to to an conclusion is the rule whose
invertibility we want to prove

there are further variations on the theme of these

Then we apply these results to prove invertibility of specific rules
for specific calculi LJ, LJA, LJT

Then some invertibility results need proving specifically, eg
can_trf_ImpRinv_lja and can_trf_ImpRinv_ljt
(invertibility of ImpR in LJA and LJT) 

Then, similarly, a general lemma for invertibility of right rules
(for which premises also have formula(e) on the right): can_trf_genRinv_lja.

Then we adapt previous proofs to LJT, first getting results for LJTSrules,
(which are the rules of LJT which have a single principal formula),
then extending them to LJTrules (noting that we can combine results
showing that can_trf_rules_rc holds, using the monotonicity
of can_trf_rules_rc, lemma can_trf_rules_rc_mono).

Much of the second half of the file is repeating similar proofs for the
systems LJA and LJT. 
Possibly more could be done by way of trying to find lemmas identifying 
common parts of two very similar proofs.

ljt_ctr.v - admissibility of contraction 

definitions: sctr_rel fml and lsctr_rel fmls define relations between two lists
of formulae, the second got by removing the second of two copies of
formula fml (for sctr_rel) or list of formulae fmls (for lsctr_rel)

for the above, fml or fmls appear at the start and end of the first list
so we need to use something like srs_ext_rel to supply the context

lemmas: 
gen_sctrL_And: if A and B are contractible, and the AndL rule is invertible,
and the AndL rule is in the calculus, then (And A B) is contractible 
gen_sctrL_Or is similar

then these are applied for the calculi LJ, LJA, LJT,
and results stated in terms of gen_step (see file gs-notes)

gs_ljg_rrules: the result in terms of gen_step where the last rule
is a right rule for And or Or (this should be pretty obvious since
we are doing contraction on the left, why is it so long to prove?)

lj[a/t]_ctr_lrls: where the last rule is a simple left rule and the subformulae
of the principal formula can be contracted, then the principal formula can
be contracted

gs_ljg_glrules: under appropriate conditions on the final rule,
the gen_step condition for contraction holds

gs_ljg_ImpR: the gen_step result for contraction where the last rule is ImpR
(for any of the calculi)

gs_lj[a]_ImpL: the gen_step result for contraction where the last rule is ImpL
for the calculus LJ[A]

ctr_adm_lj: admissibility of contraction for LJ

gs_ljg_exch: gen_step result for contraction where the last rule is exchange

gs_ljt_ImpL_atom: the gen_step result for contraction, for LJT,
where the last rule is the ImpL_atom_rule

lctr_adm_gen: extending contraction of one formula to 
contraction of a list of formulae

note, admissibility of contraction for LJT and LJA, 
  ctr_adm_ljt and ctr_adm_lja, are in ljt_dncc.v

ljt_ca.v: lemmas about cut-admissibility, 
  mostly easy ones that apply to each calculus

cedc : the property that the outcome of a cut is derivable
  (not depending on premises being derivable)

generally the lemmas prove the gen_step2 property (see file gs-notes)

examples:
gs2_lrlsL_gen: where the last rule for the left premise is a left rule
gs2_ImpLL_gen: for a specific pattern of rule, 
  useful for various Imp-left rules
gs2_rrlsR_gen: where the last rule for the right premise is a right rule
gs2_ImpRR_gen: where the ImpR rule is the last rule deriving the right premise
gs2_idL_gen: where the Id rule gives the left premise
gs2_idR_gen: where the Id rule gives the right premise
gs2_idR_gen': as above for where the Id rule is not given, but derivable

gs2_sr_princ[2]: defining special cases of gen_step2, where
  the last rule for the left premise is principal

ljg_ImpR_ImpL: where ImpR and ImpL rules on left and right respectively

gen_lrlsR_rrlsL: where principal on both sides, simple right rule on left,
left rule on right

gs2_rp[2]: linking gen_step2 to gs2_sr_princ[2]

lj_gs2_rp: showing gs2_sr_princ holds generally, where the last rule on the
right operates on the cut-formula or the succedent, for LJ

ljg_gs2: for right principal cases, showing gs2_sr_princ gives gen_step2

lj_cut_adm: cut-admissibility for LJ

lj[t/a]_adm_lj: using lj_cut_adm for LJ, LJ[T/A]rules are admissible in LJ

der_lj[t/a]_lj: anything derivable in LJ[T/A] is derivable in LJ 

ljt_dn.v: lemmas found in Dyckhoff & Negri JSL 2000
this file does not use contraction admissibility

LJX_der_id_lem: lemma used in the following
LJT_der_id, LJA_der_id: Lemma 3.2(1) of Dyckhoff & Negri JSL 2000
the axiom sequent is derivable (whether or not the formula is an atom)

LJT_der_mp, LJA_der_mp: Lemma 3.2(2) of Dyckhoff & Negri JSL 2000

note that LJT_der_id, LJA_der_id, LJT_der_mp, LJA_der_mp
do not seem to be used subsequently

then we prove Lemma 4.1 of Dyckhoff & Negri JSL 2000,
first defining l41prop (for LJA) and l41prop_t (for LJT)
which are the properties to be proved by induction, ie

l41prop D seq = forall G1 G2 : list (PropF V), seq = (G1 ++ G2, D) ->
forall B E : PropF V, derrec LJArules emptyT (fmlsext G1 G2 [B], E) ->
derrec LJArules emptyT (apfst (fmlsext G1 G2) ([Imp D B], E))

then follow some lemmas re-expressing some invertibility results

then the lemmas stating gen_step ... for l41prop[_t]
gs_LJA_ImpL_Ail, gs_LJT_ImpL_Ail: where last rule is ImpL_And or ImpL_Or
gs_LJA_ImpL_sl, gs_LJT_ImpL_sl: where last rule is an ordinary left rule
gs_LJA_ImpL_Imp_p: the atom ImpL rule of LJA
gs_LJX_ImpL_sr: where last rule is an ordinary left rule, for LJT or LJA
gs_LJX_ImpL_ImpL: where last rule is ImpL_Imp

LJT_41_atom_cases: proof of the theorem where D is an atom
  which is contained in the context 

gs_LJT_ImpL_adm: the gen_step result for any case of the last rule,
gs_LJA_ImpL_adm: the same for LJA (much shorter proof)

These give LJA_ImpL_adm, LJT_ImpL_adm: Lemma 4.1 of Dyckhoff & Negri JSL 2000

idrule_der_ljx, idrule_der_lja, idrule_der_ljt: the rule A |- A
is derivable in each system, for an implication, this uses LJ[T/A]_ImpL_adm

lja_der_atom: the ImpL_atom rule is derivable in LJA

then we prove Lemma 4.2 of Dyckhoff & Negri JSL 2000,
LJA_dn42_princ, LJT_dn42_princ:
  lemma for when the last rule is principal on the left, or a right rule

can_rel_dn42inv_ljt, can_rel_dn42inv_lja: the result for LJT or LJA

ljt_dncc.v: more lemmas from Dyckhoff & Negri JSL 2000

gen_sctrL_ImpL_And: if contraction of (Imp C (Imp D B)) is admissible,
then so is contraction of (Imp (And C D) B)),
assuming the ImpL_And rule is present and invertible (as for LJA and LJT)

gen_sctrL_ImpL_Or: a similar result for the ImpL_Or rule (used for LJA and LJT)

ljt_ctr_il: assuming contraction admissibility for any smaller formula than s
(according to the relation dnsubfml), then contraction of s is admissible,
provided s is of the form Imp (And C D) B or Imp (Or C D) B
(that is, the conclusions of the ImpL_And or ImpL_Or rules

the difficult case for Lemma 5.1 (which is contraction generally) 
(see the top of pg 1505 of Dyckhoff & Negri JSL 2000)

gs_ljx_ImpL_Imp: where Lemma 4.2 holds, and where the ImpL_Imp rule is
invertible (for its second premise), and where the ImpL_Imp rule is
in the calculus, and the last rule in a derivation is the ImpL_Imp rule,
then gen_step for contraction holds
(where the last rule in the derivation is principal, this is the case
shown at the top of pg 1505 of Dyckhoff & Negri JSL 2000)

ctr_adm_lj[a/t]: Proposition 5.1, contraction admissibility for LJ[A/T]

lj_ImpL_adm_lj[a/t]: Proposition 5.2, admissibility of LJ in LJ[A/T]

der_lj_lj[a/t]: LJ[A/T] are complete wrt LJ

lj[a/t]_cut_adm_alt: cut admissibility in LJ[A/T] proved via equivalence to LJ

for proving Proposition 5.3 of Dyckhoff & Negri JSL 2000, we define
the relevant property, to be proved by induction, that Imp A B can be
replaced by B in a sequent, the result being derivable



ljt_dnca.v:




